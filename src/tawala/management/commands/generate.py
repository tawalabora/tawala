from enum import StrEnum
from pathlib import Path
from typing import Any, Type

from christianwhocodes.generators.file import (
    FileGenerator,
    FileGeneratorOption,
    PgPassFileGenerator,
    PgServiceFileGenerator,
    SSHConfigFileGenerator,
)
from django.conf import settings
from django.core.management.base import BaseCommand, CommandParser

from ...settings.conf import Conf


class FileOption(StrEnum):
    PG_SERVICE = FileGeneratorOption.PG_SERVICE.value
    PGPASS = FileGeneratorOption.PGPASS.value
    SSH_CONFIG = FileGeneratorOption.SSH_CONFIG.value
    VERCEL = "vercel"
    ASGI = "asgi"
    WSGI = "wsgi"
    ENV = "env"


class VercelJSONFileGenerator(FileGenerator):
    f"""
    Generator for Vercel configuration file (vercel.json).

    Creates a vercel.json file in the {settings.PKG["name"].capitalize()} project base directory.
    Useful for deploying {settings.PKG["name"].capitalize()} apps to Vercel with custom install/build commands.
    """

    @property
    def file_path(self) -> Path:
        """Return the path for the vercel.json."""
        return settings.PROJECT["dirs"]["BASE"] / "vercel.json"

    @property
    def data(self) -> str:
        """Return template content for vercel.json."""
        return (
            "{\n"
            '  "$schema": "https://openapi.vercel.sh/vercel.json",\n'
            f'  "installCommand": "uv run {settings.PKG["name"]} runinstall",\n'
            f'  "buildCommand": "uv run {settings.PKG["name"]} runbuild",\n'
            '  "rewrites": [\n'
            "    {\n"
            '      "source": "/(.*)",\n'
            '      "destination": "/api/asgi"\n'
            "    }\n"
            "  ]\n"
            "}\n"
        )


class ASGIFileGenerator(FileGenerator):
    f"""
    Generator for ASGI configuration file (asgi.py).

    Creates an asgi.py file in the API directory.
    Required for running {settings.PKG["name"].capitalize()} apps with ASGI servers.
    """

    @property
    def file_path(self) -> Path:
        """Return the path for the asgi.py"""
        return settings.PROJECT["dirs"]["API"] / "asgi.py"

    @property
    def data(self) -> str:
        """Return template content for asgi.py."""
        return f"from {settings.PKG['name']}.api import asgi\n\napp = asgi.application\n"


class WSGIFileGenerator(FileGenerator):
    f"""
    Generator for WSGI configuration file (wsgi.py).

    Creates a wsgi.py file in the API directory.
    Required for running {settings.PKG["name"].capitalize()} apps with WSGI servers.
    """

    @property
    def file_path(self) -> Path:
        """Return the path for the wsgi.py."""
        return settings.PROJECT["dirs"]["API"] / "wsgi.py"

    @property
    def data(self) -> str:
        """Return template content for wsgi.py file."""
        return f"from {settings.PKG['name']}.api import wsgi\n\napp = wsgi.application\n"


class EnvVariant(StrEnum):
    """Available .env file variants."""

    DEFAULT = "default"
    EXAMPLE = "example"
    PRODUCTION = "production"
    LOCAL = "local"


class EnvFileGenerator(FileGenerator):
    f"""
    Generator for environment configuration file (.env).

    Creates a .env file in the {settings.PKG["name"].capitalize()} project base directory with all
    possible environment variables from configuration classes.
    All variables are commented out by default.
    """

    def __init__(self, variant: EnvVariant = EnvVariant.DEFAULT):
        """Initialize the generator with a specific variant.

        Args:
            variant: The .env file variant to generate
        """
        self.variant = variant

    @property
    def file_path(self) -> Path:
        """Return the path for the .env file based on variant."""
        base_dir = settings.PROJECT["dirs"]["BASE"]

        match self.variant:
            case EnvVariant.DEFAULT:
                return base_dir / ".env"
            case EnvVariant.EXAMPLE:
                return base_dir / ".env.example"
            case EnvVariant.PRODUCTION:
                return base_dir / ".env.production"
            case EnvVariant.LOCAL:
                return base_dir / ".env.local"

    @property
    def data(self) -> str:
        """Return template content for .env file."""
        variant_title = self.variant.value.replace("_", " ").title()
        if self.variant != EnvVariant.DEFAULT:
            variant_title = f"{variant_title} "
        else:
            variant_title = ""

        lines = [
            "# " + "=" * 78,
            f"# {variant_title}Environment Configuration",
            f"# Generated by {settings.PKG['name'].capitalize()}",
            "# " + "=" * 78,
            "#",
            f"# This file contains all available environment variables for your {settings.PKG['name'].capitalize()} project.",
        ]

        # Add variant-specific instructions
        match self.variant:
            case EnvVariant.EXAMPLE:
                lines.append(
                    "# * This is an example template. Copy to .env and update with actual values."
                )
            case EnvVariant.PRODUCTION:
                lines.append("# ! This file contains production environment configuration.")
                lines.append("# ! WARNING: Never commit this file to version control!")
            case EnvVariant.LOCAL:
                lines.append("# * This file contains local development overrides.")
                lines.append("# * This file is typically git-ignored.")
            case _:
                lines.append("# * Uncomment and set values as needed.")

        lines.extend(
            [
                "#",
                "# * Priority: Environment variables take precedence over pyproject.toml settings.",
                "# " + "=" * 78,
                "",
            ]
        )

        # Get all env fields from Conf subclasses
        env_fields = Conf.get_all_env_fields()

        # Group by class for better organization
        fields_by_class: dict[str, list[dict[str, Any]]] = {}
        for field in env_fields:
            class_name = field["class"]
            if class_name not in fields_by_class:
                fields_by_class[class_name] = []
            fields_by_class[class_name].append(field)

        # Generate commented-out env variables grouped by configuration class
        for idx, (class_name, fields) in enumerate(sorted(fields_by_class.items())):
            # Add separator between sections (except for first section)
            if idx > 0:
                lines.append("")

            # Section header
            lines.append("# " + "-" * 78)
            lines.append(f"# {self._format_class_name(class_name)}")
            lines.append("# " + "-" * 78)

            for field in fields:
                env_key = field["env"]
                toml_key = field["toml"]
                field_type = field["type"]
                field_name = field["name"]

                lines.append("")

                # Add descriptive comment with field name
                lines.append(f"# {field_name.replace('_', ' ').title()}")

                # Add type hint
                type_hint = self._format_type_hint(field_type)
                lines.append(f"# * Type: {type_hint}")

                # Add TOML alternative if available
                if toml_key:
                    lines.append(f"# * TOML: [tool.{settings.PKG['name']}.{toml_key}]")

                # Add the commented-out variable with example value
                example_value = self._get_example_value(field_type)
                lines.append(f"# TODO: {env_key}={example_value}")

        # Footer
        lines.append("")
        lines.append("# " + "=" * 78)
        lines.append("# End of Configuration")
        lines.append("# " + "=" * 78)

        return "\n".join(lines)

    @staticmethod
    def _format_class_name(class_name: str) -> str:
        """Format the class name for display."""
        # Remove "Conf" suffix and add spaces
        name = class_name.replace("Conf", "").replace("_", " ")
        # Handle camelCase by adding spaces
        import re

        name = re.sub(r"([a-z])([A-Z])", r"\1 \2", name)
        return f"{name.strip()} Configuration"

    @staticmethod
    def _format_type_hint(field_type: Any) -> str:
        """Format the type hint for display in comments."""
        if isinstance(field_type, str):
            return field_type
        elif field_type is bool:
            return "bool"
        elif field_type is str:
            return "str"
        elif field_type is Path:
            return "path"
        else:
            return str(field_type)

    @staticmethod
    def _get_example_value(field_type: Any) -> str:
        """Get an example value based on the field type."""
        if isinstance(field_type, str):
            if field_type == "email":
                return "user@example.com"
            elif field_type.startswith("list["):
                if "email" in field_type:
                    return "email1@example.com,email2@example.com"
                else:
                    return "value1,value2,value3"
            else:
                return "your_value_here"
        elif field_type is bool:
            return "true"
        elif field_type is Path:
            return "/path/to/directory"
        else:
            return "your_value_here"


class Command(BaseCommand):
    help: str = "Generate configuration files (e.g., .env, vercel.json, asgi.py, wsgi.py, .pg_service.conf, pgpass.conf / .pgpass, ssh config)."

    def add_arguments(self, parser: CommandParser) -> None:
        parser.add_argument(
            "-f",
            "--file",
            choices=[opt.value for opt in FileOption],
            type=FileOption,
            required=True,
            help=f"Specify which file to generate (options: {', '.join(o.value for o in FileOption)}).",
        )
        parser.add_argument(
            "--variant",
            choices=[v.value for v in EnvVariant],
            type=EnvVariant,
            default=EnvVariant.DEFAULT,
            help="Specify .env file variant (only applies when --file=env). Options: default, example, production, local.",
        )
        parser.add_argument(
            "--force",
            action="store_true",
            help="Force overwrite without confirmation.",
        )

    def handle(self, *args: Any, **options: Any) -> None:
        file_option: FileOption = FileOption(options["file"])
        force: bool = options["force"]
        variant: EnvVariant = options.get("variant", EnvVariant.DEFAULT)

        generators: dict[FileOption, Type[FileGenerator]] = {
            FileOption.VERCEL: VercelJSONFileGenerator,
            FileOption.ASGI: ASGIFileGenerator,
            FileOption.WSGI: WSGIFileGenerator,
            FileOption.PG_SERVICE: PgServiceFileGenerator,
            FileOption.PGPASS: PgPassFileGenerator,
            FileOption.SSH_CONFIG: SSHConfigFileGenerator,
        }

        # Handle ENV separately to pass variant
        if file_option == FileOption.ENV:
            generator: FileGenerator = EnvFileGenerator(variant=variant)
        else:
            generator_class: Type[FileGenerator] = generators[file_option]
            generator = generator_class()

        generator.create(force=force)

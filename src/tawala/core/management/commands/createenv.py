"""Management command: createenv - Generate .env file with all available environment variables."""

from pathlib import Path
from typing import Any, cast

from django.conf import settings
from django.core.management.base import BaseCommand, CommandError, CommandParser

from tawala.conf.management.config import (
    ApplicationConfig,
    BaseConfig,
    BuildConfig,
    DatabaseConfig,
    SecurityConfig,
    StorageConfig,
)


class Command(BaseCommand):
    """
    Tawala management command to create a .env file with all available environment variables.

    This command generates a .env file template with:
    - All environment variables defined in config classes
    - Comments showing the corresponding TOML keys
    - Default values where applicable
    - Variables are commented out by default
    """

    help = "Create a .env file template with all available environment variables"

    def add_arguments(self, parser: CommandParser) -> None:
        """Add command arguments."""
        parser.add_argument(
            "-p",
            "--path",
            dest="path",
            type=str,
            default=None,
            help="Custom path for the .env file (default: BASE_DIR/.env)",
        )
        parser.add_argument(
            "-f",
            "--force",
            "--overwrite",
            dest="overwrite",
            action="store_true",
            help="Overwrite existing .env file if it exists",
        )
        parser.add_argument(
            "--uncomment",
            action="store_true",
            help="Leave variables uncommented (active by default)",
        )

    def handle(self, *args: Any, **options: Any) -> None:
        """Execute the command."""
        # Determine the .env file path
        path_option = options.get("path")
        if path_option:
            env_path = Path(str(path_option))
        else:
            base_dir = getattr(settings, "BASE_DIR", Path.cwd())
            env_path = Path(base_dir) / ".env"

        # Check if file exists
        overwrite = bool(options.get("overwrite", False))
        if env_path.exists() and not overwrite:
            raise CommandError(
                f"File {env_path} already exists. Use --overwrite to replace it."
            )

        # Generate the .env content
        uncomment = bool(options.get("uncomment", False))
        env_content = self._generate_env_content(uncomment=uncomment)

        # Write the file
        try:
            env_path.write_text(env_content, encoding="utf-8")
            self.stdout.write(
                self.style.SUCCESS(f"Successfully created .env file at: {env_path}")
            )
        except Exception as e:
            raise CommandError(f"Failed to write .env file: {e}")

    def _generate_env_content(self, uncomment: bool = False) -> str:
        """
        Generate the content for the .env file.

        Args:
            uncomment: If True, variables will be uncommented (active)

        Returns:
            The complete .env file content as a string
        """
        config_classes: list[tuple[str, type[BaseConfig]]] = [
            ("Security", SecurityConfig),
            ("Application", ApplicationConfig),
            ("Database", DatabaseConfig),
            ("Storage", StorageConfig),
            ("Build", BuildConfig),
        ]

        lines: list[str] = [
            "# ============================================================================",
            "# Tawala Environment Configuration",
            "# ============================================================================",
            "#",
            "# This file was auto-generated by the 'createenv' management command.",
            "# Uncomment and set the values you need for your environment.",
            "#",
            "",
        ]

        for section_name, config_class in config_classes:
            # Use the new get_env_var_info() method from BaseConfig
            section_vars = config_class.get_env_var_info()

            if not section_vars:
                continue

            # Add section header
            header_lines: list[str] = [
                "",
                "# " + "=" * 76,
                f"# {section_name} Configuration",
                "# " + "=" * 76,
                "",
            ]
            lines.extend(header_lines)

            # Add each variable
            for var_info in section_vars:
                self._add_variable_lines(lines, var_info, uncomment)

        return "\n".join(lines) + "\n"

    def _add_variable_lines(
        self, lines: list[str], var_info: dict[str, Any], uncomment: bool
    ) -> None:
        """
        Add formatted lines for a single environment variable.

        Args:
            lines: The list to append lines to
            var_info: Dictionary with variable information
            uncomment: Whether to uncomment the variable
        """
        env_key: str = str(var_info["env_key"])
        toml_key: Any = var_info["toml_key"]
        default: Any = var_info["default"]

        # Add description comment
        comment_parts: list[str] = []
        if toml_key:
            comment_parts.append(f"TOML: {toml_key}")
        if default is not None:
            comment_parts.append(f"Default: {default}")

        if comment_parts:
            lines.append(f"# {' | '.join(comment_parts)}")

        # Format the value
        value: str
        if default is not None:
            if isinstance(default, bool):
                value = str(default).lower()
            elif isinstance(default, list):
                # Cast to list[Any] to satisfy type checker
                default_list = cast(list[Any], default)
                value = ",".join(str(item) for item in default_list)
            else:
                value = str(default)
        else:
            value = ""

        # Add the variable line
        prefix = "" if uncomment else "# "
        lines.append(f"{prefix}{env_key}={value}")
        lines.append("")  # Empty line for spacing
